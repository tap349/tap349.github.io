---
layout: post
title: Elixir - Metaprogramming
date: 2017-11-04 15:42:53 +0300
access: public
comments: true
categories: [elixir]
---

<!-- more -->

* TOC
{:toc}
<hr>

<dl>
  <dt>quoted</dt>
  <dd>= playbook project</dd>
</dl>

<hr>

1. <https://medium.com/@andreichernykh/elixir-a-bit-about-macros-behaviours-84fd3de1595d>
2. <https://dockyard.com/blog/2017/12/07/macro-madness-how-to-use-use-well>
3. <http://tech.honestbee.com/articles/elixir/2017-04/enums-in-elixir-ecto>

quoted expressions
------------------

> <https://elixir-lang.org/getting-started/meta/quote-and-unquote.html>
>
> When quoting more complex expressions, we can see that the code is
> represented in such tuples, which are often nested inside each other
> in a structure resembling a tree. Many languages would call such
> representations an Abstract Syntax Tree (AST). Elixir calls them
> quoted expressions.

=> AST = quoted expressions.

### AST literals

1. <https://elixir-lang.org/getting-started/meta/quote-and-unquote.html>

> there are five Elixir literals that, when quoted, return themselves
> (and not a tuple). They are:

```elixir
:sum         #=> Atoms
1.0          #=> Numbers
[1, 2]       #=> Lists
"strings"    #=> Strings
{key, value} #=> Tuples with two elements
```

=> quoted AST literals are AST literals themselves so they are:

- passed as is to macros (all other expressions are quoted - see
  `macro arguments` section below)
- can be unquoted with `unquote/1` inside macros just like quoted
  expressions (not quoted expressions must be quoted first - see
  `unquoting` section below)

quoting
-------

### macro arguments

> <https://elixir-lang.org/getting-started/meta/macros.html>
>
> arguments to a function call are evaluated before calling the function.
> macros do not evaluate their arguments - they receive the arguments as
> quoted expressions which are then transformed into other quoted expressions.

=> all macro arguments are quoted before being passed to macro
   (except for AST literals - see `AST literals` section above).

> <https://elixirforum.com/t/pass-module-to-a-macro/978/2>
>
> You donâ€™t get values into a macro but ASTs.
>
> The AST generated by the term Plug is {:__aliases__, [alias: false], [:Plug]}.
> To get the actual value out of it, you need to expand it.

if it's necessary to get the actual value of quoted expression (which is
not AST literal) inside macro before unquoting it, use `Macro.expand/2`:

```elixir
# lib/lain/page/conversation/loader.ex:
defmodule Lain.Page.Conversation.Loader do
  use Lain.CQRS.Loader, schema: Lain.Page.Conversation
end

# lib/lain/cqrs/loader.ex:
defmodule Lain.CQRS.Loader do
  defmacro __using__(opts) do
    # opts[:schema] =>
    #   {:__aliases__, [alias: false], [:Lain, :Page, :Conversation]}
    # schema =>
    #   Lain.Page.Conversation
    schema = Macro.expand(opts[:schema], __ENV__)

    quote do
      alias unquote(:"#{schema}.Query")
    end
  end
end
```

### quote/2 vs. Macro.escape/2

1. <https://elixirforum.com/t/understand-macro-escape/405/2>

> <https://hexdocs.pm/elixir/Macro.html#escape/2-comparison-to-kernel-quote-2>
>
> Macro.escape/2 is used to escape values (either directly passed or variable
> bound), while Kernel.SpecialForms.quote/2 produces syntax trees for expressions.

- `quote/2` returns AST of passed in code
- `Macro.escape/2` returns AST of passed in value

that is `Macro.escape/2` first evaluates passed expression and returns
AST of the result while `quote/2` returns AST of passed expression as is:

```elixir
# Macro.escape/1 returns :"Elixir.Lain.Page.Conversation" which is
# is printed as Lain.Page.Conversation in IEx (atom is AST literal)
Macro.escape(Lain.Page.Conversation)
# => Lain.Page.Conversation

quote do: Lain.Page.Conversation
# => {:__aliases__, [alias: false], [:Lain, :Page, :Conversation]}
```

### bind_quoted option of quote/2

> <https://hexdocs.pm/elixir/Kernel.SpecialForms.html>
>
> :bind_quoted - passes a binding to the macro. Whenever a binding is given,
> `unquote/1` is automatically disabled.

=> moreover unquoting is prohibited when using `bind_quoted` option
(that is with `unquote: false` option):

```
iex> defmodule Foo do
...>   defmacro my_macro(name) do
...>     quote bind_quoted: [name: name] do
...>       IO.puts(unquote(name))
...>     end
...>   end
...> end
iex> require Foo
iex> Foo.my_macro("foo")
** (CompileError) iex:6: unquote called outside quote
    expanding macro: Foo.my_macro/1
    iex:6: (file)
```

> <https://dockyard.com/blog/2016/08/16/the-minumum-knowledge-you-need-to-start-metaprogramming-in-elixir>
>
> bind_quoted does two things:
>
> 1) prevent accidental reevaluation of bindings
> 2) defer the execution of `unquote` via `unquote: false`

all these rules (about `bind_quoted` and unquoting) don't apply to the
functions dynamically generated inside macros - you always can and must
use `unquote/1` inside them:

```elixir
defmacro my_macro(name) do
  quote bind_quoted: [name: name] do
    IO.puts(name) # name is properly unquoted thanks to bind_quoted

    def foo do
      IO.puts(unquote(name)) # name must be always unquoted explicitly
    end
  end
end
```

unquoting
---------

1. <https://elixirforum.com/t/how-to-quote-regular-expression/6311>

only quoted expressions (or AST literals) can be unquoted with `unquote/1`
=> not quoted expressions (which are not AST literals) must be converted
to quoted expressions with `Macro.escape/2` before being unquoted inside
a macro:

```elixir
# https://github.com/elixir-lang/elixir/blob/c76c5d6d188bbb787d6afefab74a31080695d1f2/lib/elixir/lib/gen_server.ex#L702

quote location: :keep, bind_quoted: [opts: opts] do
  # ...
  # opts is a keyword list here (=> not AST literal) so it must
  # be converted to quoted expression first before being unquoted
  Supervisor.child_spec(default, unquote(Macro.escape(opts)))
  # ...
end
```

note that there'll be no error at compile time if you unquote not quoted
experssion inside a macro - error will occur when you'll try to evaluate
resulting quoted expression:

```
iex> quote do: "123" == unquote(%{a: 1})
{:==, [context: Elixir, import: Kernel], ["123", %{a: 1}]}
iex> Code.eval_quoted(quote do: "123" == unquote(%{a: 1}))
** (CompileError) nofile: invalid quoted expression: %{a: 1}
    (stdlib) lists.erl:1354: :lists.mapfoldl/3
    (stdlib) lists.erl:1355: :lists.mapfoldl/3
iex> Code.eval_quoted(quote do: "123" == unquote(Macro.escape(%{a: 1})))
{false, []}
```

`use` macro
-----------

1. <https://dockyard.com/blog/2017/12/07/macro-madness-how-to-use-use-well>
