---
layout: post
title: Phoenix
date: 2016-11-12 16:21:40 +0300
access: public
categories: [phoenix]
---

Phoenix notes (mostly based on "Programming Phoenix" by Chris McCord).

<!-- more -->

* TOC
{:toc}

## using IEx with Phoenix app

- `iex` - doesn't load your app (equivalent of `irb`)
- `iex -S mix` - loads your app by executing _mix.exs_ script
  (equivalent of `rails console`)
- `iex -S mix phoenix.server` - loads your app and launches web server
  (`rails console` inside `rails server` - or vice versa)

## Mix tasks

- `mix phx.server` = `rails server`
- `mix phx.routes` = `rake routes`

## templates

<https://hexdocs.pm/phoenix/1.3.0-rc.3/adding_pages.html>

in templates properties from `assigns` can be accessed with `@`
(it's not module attribute in this case): `@user` = `assigns.user`.

## endpoints

<https://hexdocs.pm/phoenix/1.3.0-rc.3/routing.html#path-helpers>:

> Think of endpoints as the entity that handles requests just up to the point
> where the router takes over. That includes starting the app/server, applying
> configuration, and applying the plugs common to all requests.

<https://hexdocs.pm/phoenix/1.3.0-rc.3/endpoint.html>:

> Phoenix applications starts the HelloWeb.Endpoint as a supervised process.
> By default, the Endpoint is added to the supervision tree in
> lib/hello/application.ex as a supervised process. Each request begins and
> ends its lifecycle inside your application in an endpoint. The endpoints
> handles starting the web server and transforming requests through several
> defined plugs before calling the Router.

> Endpoints gather together common functionality and serve as entrance and
> exit for all of the HTTP requests to your application. The endpoint holds
> plugs that are common to all requests coming into your application.

> If code reloading is enabled, a socket will be used to communicate to the
> browser that the page needs to be reloaded when code is changed on the server.

> It is also possible for an application to have multiple endpoints,
> each with its own supervision tree.

## routes

<https://hexdocs.pm/phoenix/1.3.0-rc.3/routing.html>

> - Routes which begin with an HTTP verb name expand to a single clause of the match function.
> - Routes which begin with ‘resources’ expand to 8 clauses of the match function.
> - Resources may restrict the number of match function clauses by using the only: or except: options.
> - Any of these routes may be nested.
> - Any of these routes may be scoped to a given path.
> - Using the as: helper option in a scope can reduce duplication.
> - Using the as: helper option for scoped routes eliminates unreachable paths.

### `as:` option

<https://hexdocs.pm/phoenix/1.3.0-rc.3/routing.html#scoped-routes>

passing `as:` for `scope` option allows to change the name of path helpers
for all routes inside `scope` block:

```elixir
scope "/v1", as: :v1 do
  get "/cards", CardController
  # other routes
end
```

or else it's possible to do it on per-route basis by passing `as:` option
to individual routes:

```elixir
scope "/v1" do
  get "/cards", CardController, as: :v1
  # other routes
end
```

### scopes

<https://hexdocs.pm/phoenix/1.3.0-rc.3/routing.html#scoped-routes>

> Note that Phoenix will assume that the path we set ought to begin with a slash,
> so scope "/admin" do and scope "admin" do will both produce the same results.

according to my experience this is not true:

```elixir
scope "/", BillingWeb do
  pipe_through :api

  scope "v1" do
    # ...
  end
end
```

```sh
$ mix phx.routes
warning: router paths should begin with a forward slash, got: "v1"
```

## plugs

<https://hexdocs.pm/phoenix/1.3.0-rc.3/plug.html>

> The basic idea of Plug is to unify the concept of a “connection” that we
> operate on. This differs from other HTTP middleware layers such as Rack,
> where the request and response are separated in the middleware stack.

module plug:

> The module only needs to implement two functions:
>
> - init/1 which initializes any arguments or options to be passed to call/2
> - call/2 which carries out the connection transformation. call/2 is just a
>   function plug that we saw earlier

## controllers

<https://hexdocs.pm/phoenix/1.3.0-rc.3/controllers.html>

> Phoenix controllers also build on the Plug package, and are themselves plugs.

> A step beyond this is rendering pure JSON with the json/2 function. We need
> to pass it something that the Poison library can parse into JSON, such as a map.

> It is worth noting that the text/2, json/2, and html/2 functions require
> neither a Phoenix view, nor a template to render.

> Phoenix allows us to change formats on the fly with the _format query string parameter.

if no format is specified explicitly with `_format` query parameter it's
considered to be the first one accepted by current pipeline in router
(say, `json` format for request that is processed with `api` pipeline).

## views

<https://hexdocs.pm/phoenix/1.3.0-rc.3/views.html>

> If you are familiar with decorators or the facade pattern, this is similar.

> Note that we didn’t need to fully qualify title/0 with HelloWeb.LayoutView
> because our LayoutView actually does the rendering (it's a local function call).
> In fact, “templates” in Phoenix area really just function definitions on their
> view module.

> At compile-time, Phoenix precompiles all *.html.eex templates and turns them
> into render/2 function clauses on their respective view modules. At runtime,
> all templates are already loaded in memory.

say, we can replace _page/index.html.eex_ with the following `render/2` function:

```elixir
defmodule HelloWeb.PageView do
  use HelloWeb, :view

  def render("index.html", assigns) do
    # html string with interpolated variables from `assigns` map
  end
end
```

we can render any template manually in IEx:

```elixir
Phoenix.View.render(HelloWeb.PageView, "test.html", %{})
```

this is how any template is rendered inside layout:

```elixir
<%= render @view_module, @view_template, assigns %>
```
