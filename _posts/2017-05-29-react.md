---
layout: post
title: React
date: 2017-05-29 10:12:57 +0300
access: public
categories: [react]
---

extracts from React's 'Quick Start'.

<!-- more -->

## tutorial

<https://facebook.github.io/react/docs/rendering-elements.html>:

> thinking about how the UI should look at any given moment rather
> than how to change it over time eliminates a whole class of bugs

<https://facebook.github.io/react/docs/components-and-props.html>:

> Components accept arbitrary inputs (called "props") and return
> React elements describing what should appear on the screen.

components can be defined using plain function or ES6 class:

```javascript
// functional component
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

// class component
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

elements can also represent user-defined components:

```javascript
const element = <Welcome name="Sara" />;
```

> When React sees an element representing a user-defined component,
> it passes JSX attributes to this component as a single object called "props".

> Components must return a single root element.

> if part of your UI is used several times (Button, Panel) or is complex enough
> on its own (App, Comment), it is a good candidate to be a reusable component.

> All React components must act like pure functions with respect to their props.

<https://facebook.github.io/react/docs/state-and-lifecycle.html>:

class components have additional features: local state and lifecycle hooks.

## Redux

<http://redux.js.org/docs/basics/>

> The whole state of your app is stored in an object tree inside a single store.

> The only way to change the state tree is to emit an action, an object describing what happened.

> To specify how the actions transform the state tree, you write pure reducers.

### actions

> Actions are payloads of information that send data from your application
> to your store. They are the only source of information for the store.
> You send them to the store using store.dispatch().

```javascript
{
  type: TOGGLE_TODO,
  index: 5
}
```

> Action creators are functions that create actions.

```javascript
function addTodo(text) {
  return {
    type: TOGGLE_TODO,
    text
  }
}
```

### reducers

> The reducer is a pure function that takes the previous state and an action,
> and returns the next state.

```javascript
(previousState, action) => newState
```

> Things you should never do inside a reducer:

- mutate its arguments
- produce side effects like API calls and routing transitions
- call non-pure functions (say, `Date.now()` or `Math.random()`)

#### reducer composition

<http://redux.js.org/docs/basics/Reducers.html#splitting-reducers>

reducer composition (fundamental pattern of Redux) -
delegating a slice of state to manage to child reducers.

NOTE: it's possible to nest child reducers!
      say, child reducer to change `user` state field might call
      another child reducer to change user's name.

every reducer on any level receives part of state it manages on this level
and current action and should return the same part of state with merged changes.

without reducer composition:

- new values for state fields are merged into global state in `case` clauses
  for each action type (different action types change different state fields)
- initial state is a global constant and is used as `state` parameter default
  value in main/root (and the only) reducer

with reducer composition:

- each state field is managed independently by dedicated child reducer
  (which receives only part of state it manages and current action)
- initial state of state fields is managed by corresponding child reducers

classic style (without reducer composition):

```javascript
const initialState = {
  count: 0
}

export default function badges(state = initialState, action = {}) {
  switch(action.type) {
    case BADGES_SET_COUNT:
      return {
        ...state,
        count: action.count
      }
    default:
      return state
  }
}
```

with reducer composition (but without using `combineReducers`):

```javascript
function count(state = 0, action) {
  switch(action.type) {
    case BADGES_SET_COUNT:
      return action.count
    default:
      return state
  }
}

export default function badges(state, action) {
  return {
    noti_count: noti_count(state.noti_count, action)
  }
}
```

with reducer composition (using `combineReducers`):

```javascript
import { combineReducers } from 'redux'

function count(state = 0, action) {
  switch(action.type) {
    case BADGES_SET_COUNT:
      return action.count
    default:
      return state
  }
}

const badges = combineReducers(
  {
    noti_count
  }
)

export default badges
```

### store

- create (say, in _Store.js_):

  ```javascript
  import { createStore } from 'redux'
  import badges from './reducers'

  export default createStore(badges)
  ```

- get current state:

  ```javascript
  import store from './Store'

  let state = store.getState()
  ```

- change state by dispatching actions:

  ```javascript
  import store from './Store'
  import * as badgeActions from './actions/badgeActions'

  store.dispatch(badgeActions.setCount(3))
  ```

- listen to state updates

  ```javascript
  import store from './Store'

  store.subscribe(() => this.forceUpdate())
  ```

  every time state changes listener is called
  (which re-renders root component in this example).
