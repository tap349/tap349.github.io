---
layout: post
title: Ansible
date: 2018-06-19 01:34:36 +0300
access: private
comments: true
categories: [ansible]
---

<!-- more -->

* TOC
{:toc}
<hr>

<dl>
  <dt>Ansible project</dt>
  <dd>= playbook project</dd>

  <dt>playbook</dt>
  <dd>consists of plays</dd>

  <dt>play</dt>
  <dd>maps a group of hosts to roles in playbook</dd>

  <dt>import_role</dt>
  <dd>= module, directive or statement</dd>

  <dt>included role</dt>
  <dd>role loaded using import_role or include_role</dd>

  <dt>recursive loop</dt>
  <dd>infinite recursion</dd>

  <dt>passing through variables</dt>
  <dd>
    passing variables to template or included role which are defined
    in terms of already existing variables with the same name and in
    the same scope (say, <code>app_user: "{{ app_user }}"</code>)
  </dd>
</dl>

<hr>

1. <https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html>
2. <https://github.com/leucos/ansible-tuto>

installation
------------

```sh
$ brew install ansible
```

add SSH config entry for remote node:

```sshconfig
# .ssh/config

Host sithex
 User root
 Hostname DIGITAL_OCEAN_IP
 IdentityFile ~/.ssh/id_rsa
 ForwardAgent yes
```

install Python on remote node:

```sh
$ ssh sithex
# apt install python
```

configuration
-------------

create inventory file:

> <https://github.com/leucos/ansible-tuto/tree/master/step-03>
>
> Hosts in inventory can be grouped arbitrarily. For instance, you could
> have a debian group, a web-servers group, a production group, etc...

```yaml
[web]
sithex
```

`[web]` here is a group name (optional).

now ping all nodes:

> <https://github.com/leucos/ansible-tuto/tree/master/step-02>
>
> `all` is a shortcut meaning 'all hosts found in inventory file'.

```
$ ansible all -m ping
sithex | SUCCESS => {
    "changed": false,
    "ping": "pong"
}
```

execute shell command on specific node:

```
$ ansible sithex -m shell -a 'date'
sithex | SUCCESS | rc=0 >>
Mon Jun 18 22:58:35 UTC 2018
```

notes
-----

### roles

roles are executed once within one play only (where hosts are specified) -
not across all plays and playbooks in Ansible project:

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html>
>
> Ansible will only allow a role to execute once, even if defined multiple times,
> if the parameters defined on the role are not different for each definition.

#### role dependencies

> <https://docs.ansible.com/ansible/devel/user_guide/playbooks_reuse_roles.html#role-dependencies>
>
> Role dependencies must use the classic role definition style.

```yaml
# roles/sithex_app/meta/main.yml

dependencies:
  - role: elixir
```

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html>
>
> Role dependencies are always executed before the role that includes them, and
> may be recursive. Dependencies also follow the duplication rules specified above.

#### role dependencies vs. include_role

1. <https://github.com/ansible/ansible/issues/23733>

it looks like they serve the same purpose - to execute a role passing
parameters when required:

```yaml
# roles/sithex_app/meta/main.yml
# role dependency

dependencies:
  - role: elixir
    app_name: "{{ app['name'] }}"
    app_user: "{{ app['user'] }}"

# roles/sithex_app/tasks/main.yml
# include_role

- include_role: name=elixir_app
  vars:
    app_name: "{{ app['name'] }}"
    app_user: "{{ app['user'] }}"
```

the only difference I see is that role dependencies are always executed
before the role that includes them while `include_role` directive can be
inserted anywhere among other role tasks.

in both cases roles follow duplication rules (see `roles` section above).

currently I use role dependecies to install system dependencies (like
install Elixir itself) and `include_role` - to configure application
(like create users, directories, etc.).

***UPDATE***

I guess it's easier to use `include_role` directive all the time so that
all included roles are listed explicitly in _roles/my_app/tasks/main.yml_.

#### include_role vs. import_role

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html>
>
> When roles are defined in the classic manner, they are treated as static
> imports and processed during playbook parsing.

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html#includes-vs-imports>
>
> - All import* statements are pre-processed at the time playbooks are parsed.
> - All include* statements are processed as they encountered during the execution
>   of the playbook.

I still can't understand the difference between these directives and use
`import_role` one because it seems to be more strict.

### tasks

#### `pre_tasks` section

> <https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play>
>
> pre_tasks
>   A list of tasks to execute before roles.

> <https://github.com/Mohitsharma44/ansible-playbooks/wiki/vars-pre-post-and-handlers#pre_tasks-and-post_tasks>
>
> A general use case for pre_task could be when you need to make sure that your
> system package manager's cache is updated.

### variables

1. <https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html>

variables are always referenced using `{{ var }}` syntax of Jinja2 templating
system - even if they are not interpolated inside another string:

```yaml
- name: Create secrets file
  copy:
    src: "{{ env }}.secret.exs"
    dest: "/var/{{ env }}.secret"
    owner: sithex
    group: sithex
    mode: 0660
```

passed variables propagate to all included roles: say, role A → role B → role C.
if role A passes `foo` variable to role B, this variable is available in role C
too without passing it to role C explicitly - it's true for both `include_role`
and `import_role` modules.

#### `vars` section

> <https://stackoverflow.com/a/42109037>
>
> Role variables defined in `vars` have a very high precedence - they can only
> be overwritten by passing them on the command line, in the specific task or in
> a block. Therefore, almost all your variables should be defined in `defaults`.

> <https://codereviewvideos.com/course/ansible-tutorial/video/variable-precedence-where-to-put-your-role-vars>
>
> I use `vars` directory for system specific variables.
>
> Everything else - all standard, shared variables we would need and anything
> we want the user of our Role to override should go in `defaults/main.yml`.

=> use _vars/_ directory for almost all app role variables (since they are not
meant to be configured from outside).

### SSH user

1. <https://docs.ansible.com/ansible/2.4/intro_configuration.html#remote-user>

> <https://stackoverflow.com/a/36677811>
>
> Besides, ansible_user is used when we want to specifiy default SSH user in
> ansible hosts file where as remote_user is used in playbook context.

by default user from corresponding entry in SSH config is used but it might
be app user so it's better to specify SSH user to run Ansible as explicitly:

```cfg
# ansible.cfg

[defaults]

# formerly known as `user`
remote_user = root
```

### file paths

NOTE: these rules apply to template paths as well.

file paths can be specified relative to:

- _files/_ directory (inside current role)

  ```yaml
  # roles/sithex_app/tasks/secrets.yml

  - name: Create secrets file
    copy:
      # => roles/sithex_app/files/prod.secret.exs
      src: "{{ env }}.secret.exs"
      dest: "/var/{{ env }}.secret.exs"
      owner: "{{ app['user'] }}"
      group: "{{ app['user'] }}"
      mode: 0660
  ```

- Ansible project root

  ```yaml
  # roles/sithex_app/tasks/secrets.yml

  - name: Create secrets file
    copy:
      # => roles/sithex_app/files/prod.secret.exs
      src: "roles/sithex_app/files/{{ env }}.secret.exs"
      dest: "/var/{{ env }}.secret.exs"
      owner: "{{ app['user'] }}"
      group: "{{ app['user'] }}"
      mode: 0660
  ```

  this path can be passed as an argument to another role:

  ```yaml
  # roles/sithex_app/tasks/main.yml

  - include_role: name=elixir_app
    vars:
      app_name: "{{ app['name'] }}"
      app_user: "{{ app['user'] }}"
      secrets_path: "roles/sithex_app/files/{{ env }}.secret.exs"
  ```

tips
----

### common roles directory for Ansible projects

> <https://docs.ansible.com/ansible/devel/user_guide/playbooks_reuse_roles.html#role-search-path>
>
> In Ansible 1.4 and later you can configure an additional roles_path to
> search for roles. Use this to check all of your common roles out to one
> location, and share them easily between multiple playbook projects.

style guide
-----------

### *[OPTIONAL]* don't use common app variables

common app variables are stored in _vars/main.yml_ (this file becomes
obsolete if these variables are no longer used):

```yaml
# roles/sithex_app/vars/main.yml

app:
  name: sithex
  user: sithex
```

it's much easier to hardcode these values rather than reference through
variables:

```diff
  - name: Create secrets file
    copy:
      src: "{{ env }}.secret.exs"
      dest: "/var/{{ env }}.secret.exs"
-     owner: "{{ app['user'] }}"
-     group: "{{ app['user'] }}"
+     owner: sithex
+     group: sithex
      mode: 0660
```

it might be not very dry but it doesn't seem to cause any trouble so far.

***UPDATE***

still I continue to use common app variables except for _files/*.secret.exs_
files (note they are not even templates and are not parameterized at all).

### update package index implicitly with caching

1. <https://github.com/LunarLogic/ansible-elixir-playbooks/blob/master/roles/install_postgresql/0.0.1/tasks/main.yml>

NOTE: package index is known as `apt cache` in Ansible docs:

> <https://docs.ansible.com/ansible/latest/modules/apt_module.html>
>
> cache_valid_time
>   Update the apt cache if its older than the cache_valid_time.

```yaml
# roles/common/tasks/packages.yml

# update explicitly
- name: Update package index
  apt:
    state: present
    update_cache: yes
    cache_valid_time: 3600

# [RECOMMENDED] update implicitly
- name: Install common packages
  apt:
    name: "{{ item }}"
    state: present
    update_cache: yes
    cache_valid_time: 3600
  loop: "{{ packages }}"
```

### never pass `env` variable explicitly to included roles

treat it like a global variable which is available everywhere, don't
check it's defined before role execution - always assume it is.

### *[OPTIONAL]* always pass local variables to templates

1. <https://stackoverflow.com/a/38653180/3632318>

just like when rendering partials in Rails: pass all local variables
explicitly and don't reference global variables inside partials (even
though they will be available there) - except for `env` variable (see
the previous rule).

`vars` section is used to pass local variables to the template:

```yaml
# roles/sithex_app/tasks/foo.yml

- template:
    src: "foo_{{ env }}.conf"
    dest: "/etc/foo_{{ env }}.conf"
    vars:
      app_name: "{{ app_name }}"
```

***UPDATE***

I have refused from passing through variables to templates since it might lead
to recursive loop - just like when passing through variables to included roles
(see `troubleshooting` section below).

### don't extract variables into vars/*.yml files unless necessary

it's necessary if these variables are used/included in many places or they
contain lots of data which might be hard to inline (say, SSH keys).

don't extract, say, packages to install or directories to create which are
used in one task only:

```yaml
- name: Install common packages
  apt:
    name: "{{ item }}"
    update_cache: yes
    cache_valid_time: 3600
    state: present
  loop:
    - git
    - htop
    - mc
    - ccze
```

### don't use shorthand syntax for `include_vars` module

in general always use parameter names to avoid ambiguity:

```yaml
# bad
- include_vars: "{{ item }}"
  loop:
    - dirs.yml
    - "nginx_{{ env }}.yml"

# good
- include_vars:
    file: "{{ item }}"
  loop:
    - dirs.yml
    - "nginx_{{ env }}.yml"
```

### don't use Jinja2 templating delimiters in when statements

1. <https://github.com/ansible/ansible/issues/22397>

```yaml
# bad
- name: Upload SSL files
  copy:
    src: "{{ ssl_dir }}/"
    dest: "{{ env_dir }}/nginx/ssl"
  when: "{{ use_ssl }}"

# good
- name: Upload SSL files
  copy:
    src: "{{ ssl_dir }}/"
    dest: "{{ env_dir }}/nginx/ssl"
  when: use_ssl
```

environments
------------

1. <https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#alternative-directory-layout>
2. <https://www.digitalocean.com/community/tutorials/how-to-manage-multistage-environments-with-ansible#using-ansible-constructs-that-allow-explicit-loading-order>

```yaml
# inventories/prod/group_vars/all

env: prod
```

```yaml
# inventories/stage/group_vars/all

env: stage
```

now `env` variable is available in all plays and roles.

troubleshooting
---------------

### recursive loop detected in template string

1. <https://stackoverflow.com/a/21738751>

passing through variables to included roles might lead to recursive loop
inside the template:

```
recursive loop detected in template string: {{ app_user }}
```

**solution**

1. <https://coderleaf.wordpress.com/2017/07/06/ansible-check-for-required-variables-before-role-execution/>

the only solution that actually works in the end is to give up and not to
pass through such variables to templates and included roles - in any case
they'll be available in all templates and nested roles.

a major drawback of this solution is that you are not explicit about role
parameters - this shortcoming can be mitigated by declaring required role
parameters in _defaults/main.yml_ and checking that they're defined right
before role execution:

> <https://coderleaf.wordpress.com/2017/07/06/ansible-check-for-required-variables-before-role-execution/>
>
> Ansible does not provide a standard way to check that required variables
> are defined before executing a tsak.
>
> Ansible, relies instead on the standard mechanism of a task failing if a
> variable being used has not been defined.
>
> Sometimes you want to make sure that all required variables are defined
> before starting the tasks for a role.

```yaml
# roles/elixir_app/defaults/main.yml

required_vars:
  - app_name
  - app_user
  - secrets_file
  - ssl_dir
```

```yaml
# roles/elixir_app/tasks/main.yml

- name: Check required vars
  fail: msg="Variable '{{ item }}' is not defined"
  when: item not in vars
  loop: "{{ required_vars }}"

# other tasks...
```
