---
layout: post
title: Ansible
date: 2018-06-19 01:34:36 +0300
access: public
comments: true
categories: [ansible]
---

<!-- more -->

* TOC
{:toc}
<hr>

<dl>
  <dt>Ansible project</dt>
  <dd>= playbook project</dd>

  <dt>playbook</dt>
  <dd>consists of plays</dd>

  <dt>play</dt>
  <dd>maps a group of hosts to roles in playbook</dd>

  <dt>import_role</dt>
  <dd>= module, directive or statement</dd>

  <dt>included role</dt>
  <dd>role loaded using import_role or include_role</dd>

  <dt>recursive loop</dt>
  <dd>infinite recursion</dd>

  <dt>passing through variables</dt>
  <dd>
    passing variables to template or included role which are defined
    in terms of already existing variables with the same name and in
    the same scope (say, <code>app_user: "{{ app_user }}"</code>)
  </dd>
</dl>

<hr>

1. <https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html>
2. <https://github.com/leucos/ansible-tuto>

installation
------------

```sh
$ brew install ansible
```

add SSH config entry for remote node:

```sshconfig
# .ssh/config

Host sithex
 User root
 Hostname DIGITAL_OCEAN_IP
 IdentityFile ~/.ssh/id_rsa
 ForwardAgent yes
```

install Python on remote node:

```sh
$ ssh sithex
# apt install python
```

configuration
-------------

create inventory file:

> <https://github.com/leucos/ansible-tuto/tree/master/step-03>
>
> Hosts in inventory can be grouped arbitrarily. For instance, you could
> have a debian group, a web-servers group, a production group, etc...

```yaml
[web]
sithex
```

`[web]` here is a group name (optional).

now ping all nodes:

> <https://github.com/leucos/ansible-tuto/tree/master/step-02>
>
> `all` is a shortcut meaning 'all hosts found in inventory file'.

```
$ ansible all -m ping
sithex | SUCCESS => {
    "changed": false,
    "ping": "pong"
}
```

execute shell command on specific node:

```
$ ansible sithex -m shell -a 'date'
sithex | SUCCESS | rc=0 >>
Mon Jun 18 22:58:35 UTC 2018
```

notes
-----

### roles

roles are executed once within one play only (where hosts are specified) -
not across all plays and playbooks in Ansible project:

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html>
>
> Ansible will only allow a role to execute once, even if defined multiple times,
> if the parameters defined on the role are not different for each definition.

#### role dependencies

> <https://docs.ansible.com/ansible/devel/user_guide/playbooks_reuse_roles.html#role-dependencies>
>
> Role dependencies must use the classic role definition style.

```yaml
# roles/sithex_app/meta/main.yml

dependencies:
  - role: elixir
```

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html>
>
> Role dependencies are always executed before the role that includes them, and
> may be recursive. Dependencies also follow the duplication rules specified above.

#### role dependencies vs. include_role

1. <https://github.com/ansible/ansible/issues/23733>

it looks like they serve the same purpose - to execute a role passing
parameters when required:

{% raw %}
```yaml
# roles/sithex_app/meta/main.yml
# role dependency

dependencies:
  - role: elixir
    app_name: "{{ app__app_name }}"
    app_user: "{{ app__app_user }}"

# roles/sithex_app/tasks/main.yml
# include_role

- include_role: name=elixir_app
  vars:
    app_name: "{{ app__app_name }}"
    app_user: "{{ app__app_user }}"
```
{% endraw %}

the only difference I see is that role dependencies are always executed
before the role that includes them while `include_role` can be inserted
anywhere among other role tasks.

in both cases roles follow duplication rules (see `roles` section above).

currently I use role dependecies to install system dependencies (like
install Elixir itself) and `include_role` - to configure application
(like create users, directories, etc.).

***UPDATE***

I guess it's easier to use `include_role` (or `import_role` to be precise -
see below) all the time so that all included roles are listed explicitly in
one file (_roles/my_app/tasks/main.yml_).

#### include_role vs. import_role

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html>
>
> When roles are defined in the classic manner, they are treated as static
> imports and processed during playbook parsing.

> <https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html#includes-vs-imports>
>
> - All import* statements are pre-processed at the time playbooks are parsed.
> - All include* statements are processed as they encountered during the execution
>   of the playbook.

I still can't understand the difference between these directives and use
`import_role` one because it seems to be more strict.

### tasks

#### `pre_tasks` section

> <https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play>
>
> pre_tasks
>   A list of tasks to execute before roles.

> <https://github.com/Mohitsharma44/ansible-playbooks/wiki/vars-pre-post-and-handlers#pre_tasks-and-post_tasks>
>
> A general use case for pre_task could be when you need to make sure that your
> system package manager's cache is updated.

### variables

1. <https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html>

variables are always referenced using `{{ var }}` syntax of Jinja2 templating
system - even if they are not interpolated inside another string:

```yaml
- name: Create secrets file
  copy:
    src: "{{ env }}.secret.exs"
    dest: "/var/{{ env }}.secret"
    owner: sithex
    group: sithex
    mode: 0660
```

passed variables propagate to all included roles: say, role A → role B → role C.
if role A passes `foo` variable to role B, this variable is available in role C
too without passing it to role C explicitly - it's true for both `include_role`
and `import_role` modules.

variables included with `include_vars` are always hoisted within the file so
it makes sense to place them at the very top to make this behaviour explicit
but still I prefer to include variables closer to where they are used.

#### `vars` section

> <https://stackoverflow.com/a/42109037>
>
> Role variables defined in `vars` have a very high precedence - they can only
> be overwritten by passing them on the command line, in the specific task or in
> a block. Therefore, almost all your variables should be defined in `defaults`.

> <https://codereviewvideos.com/course/ansible-tutorial/video/variable-precedence-where-to-put-your-role-vars>
>
> I use `vars` directory for system specific variables.
>
> Everything else - all standard, shared variables we would need and anything
> we want the user of our Role to override should go in `defaults/main.yml`.

=> use _vars/_ directory for almost all app role variables (since they are not
meant to be configured from outside).

### templates

{% raw %}
for some reason both `{% if ... %}` and `{% endif %}` statements indent the
next line - use `{% if ... -%}` to disable indentation of the first line of
the block and `{%- endif %}` with empty line to disable indentation of the
first line after the block (it's kind of a hack: `{%- endif %}` effectively
removes the next empty line by removing newline at the end of current line):
{% endraw %}

{% raw %}
```conf
# roles/nginx/templates/app_site.j2

server {
  # ...

  {% if nginx__use_ssl -%}
  ssl_certificate {{ ssl_certificate }};
  ssl_certificate_key {{ ssl_certificate_key }};

  ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers "RC4:HIGH:!aNULL:!MD5:!kEDH";
  {%- endif %}

}
```
{% endraw %}

### SSH user

1. <https://docs.ansible.com/ansible/2.4/intro_configuration.html#remote-user>

> <https://stackoverflow.com/a/36677811>
>
> Besides, ansible_user is used when we want to specifiy default SSH user in
> ansible hosts file where as remote_user is used in playbook context.

by default user from corresponding entry in SSH config is used but it might
be app user so it's better to specify SSH user to run Ansible as explicitly:

```cfg
# ansible.cfg

[defaults]

# formerly known as `user`
remote_user = root
```

### file paths

NOTE: these rules apply to template paths as well.

file paths can be specified relative to:

- _files/_ directory (inside current role)

  {% raw %}
  ```yaml
  # roles/sithex_app/tasks/secrets.yml

  - name: Create secrets file
    copy:
      # => roles/sithex_app/files/prod.secret.exs
      src: "{{ env }}.secret.exs"
      dest: "/var/{{ env }}.secret.exs"
      owner: "{{ app__app_user }}"
      group: "{{ app__app_user }}"
      mode: 0660
  ```
  {% endraw %}

- Ansible project root

  {% raw %}
  ```yaml
  # roles/sithex_app/tasks/secrets.yml

  - name: Create secrets file
    copy:
      # => roles/sithex_app/files/prod.secret.exs
      src: "roles/sithex_app/files/{{ env }}.secret.exs"
      dest: "/var/{{ env }}.secret.exs"
      owner: "{{ app__app_user }}"
      group: "{{ app__app_user }}"
      mode: 0660
  ```
  {% endraw %}

  this path can be passed as an argument to another role:

  {% raw %}
  ```yaml
  # roles/sithex_app/tasks/main.yml

  - include_role: name=elixir_app
    vars:
      app_name: "{{ app__app_user }}"
      app_user: "{{ app__app_user }}"
      secrets_path: "roles/sithex_app/files/{{ env }}.secret.exs"
  ```
  {% endraw %}

tips
----

### common roles directory for Ansible projects

> <https://docs.ansible.com/ansible/devel/user_guide/playbooks_reuse_roles.html#role-search-path>
>
> In Ansible 1.4 and later you can configure an additional roles_path to
> search for roles. Use this to check all of your common roles out to one
> location, and share them easily between multiple playbook projects.

style guide
-----------

### don't extract all variables into _vars/*.yml_ files

sometimes it's easier to hardcode specific values (especially if these values
are used in one place only):

{% raw %}
```diff
  # roles/common/tasks/packages.yml

  - include_vars: file=packages.yml

  - name: Install common packages
    apt:
      name: "{{ item }}"
      update_cache: yes
      cache_valid_time: 3600
      state: present
-   loop: "{{ common__packages }}"
+   loop:
+     - git
+     - htop
+     - mc
+     - ccze
```
{% endraw %}

### update package index implicitly with caching

1. <https://github.com/LunarLogic/ansible-elixir-playbooks/blob/master/roles/install_postgresql/0.0.1/tasks/main.yml>

NOTE: package index is known as `apt cache` in Ansible docs:

> <https://docs.ansible.com/ansible/latest/modules/apt_module.html>
>
> cache_valid_time
>   Update the apt cache if its older than the cache_valid_time.

{% raw %}
```yaml
# roles/common/tasks/packages.yml

# update explicitly
- name: Update package index
  apt:
    state: present
    update_cache: yes
    cache_valid_time: 3600

# [RECOMMENDED] update implicitly
- name: Install common packages
  apt:
    name: "{{ item }}"
    state: present
    update_cache: yes
    cache_valid_time: 3600
  loop: "{{ packages }}"
```
{% endraw %}

### never pass `env` variable to roles and templates explicitly

treat it like a global variable which is available everywhere and
don't check it's defined before role execution - assume it always is.

### use role prefix for all variables inside the role

> <https://blog.opsfactory.rocks/ansible-roles-and-default-variables-9bcd379bae3f>
>
> When writing your default variables, namespace them. Ansible’s
> memory model for variables is essentially flat and global.

prefix all role variables (both passed to the role from outside and
defined inside _vars/*.yml_ files) with a role name and use double
underscore as a delimiter:

{% raw %}
```yaml
# roles/postgresql/vars/databases.yml

postgresql__databases:
  - name: "{{ postgresql__app_name }}_{{ env }}"
```
{% endraw %}

```yaml
# roles/postgresql/defaults/main.yml

postgresql__required_vars:
  - postgresql__app_name
```

=> ALL variables inside any given role MUST have a role prefix!

the only exception is `env` variable which I've decided to make available
globally.

NOTE: using role-prefixed variables allows to avoid recursive loop error
      (see `troubleshooting` section).

### always pass local variables to templates

1. <https://stackoverflow.com/a/38653180/3632318>

just like when rendering partials in Rails: pass all local variables
explicitly and don't reference global variables inside partials (even
though they will be available there) - except for `env` variable (see
the previous rule).

`vars` section is used to pass local variables to the template:

{% raw %}
```yaml
# roles/sithex_app/tasks/foo.yml

- template:
    src: "foo_{{ env }}.conf"
    dest: "/etc/foo_{{ env }}.conf"
    vars:
      app_name: "{{ app__app_name }}"
```
{% endraw %}

don't use role-prefixed variables inside the template: local variables
must be passed to the template without a role prefix - I hope these
variables stay local to the template and cannot sneak into other roles
potentially causing mayhem there.

{% raw %}
```yaml
# roles/nginx/tasks/configure.yml

- name: Create app site
  template:
    src: app_site.j2
    dest: "/etc/nginx/sites-available/{{ nginx__app_site }}"
    # ...
  vars:
    # role-prefixed variables must be referenced through local variables
    app_site: "{{ nginx__app_site }}"
    # local variables cannot have a role prefix
    ssl_certificate: "{{ nginx__ssl_dir }}/{{ nginx__app_name }}.pem"
    ssl_certificate_key: "{{ nginx__ssl_dir }}/{{ nginx__app_name }}.key"
    # ...
```
{% endraw %}

NOTE: passing through variables to templates might lead to recursive
      loop - just like when passing through variables to included roles
      (see `troubleshooting` section below).

### don't extract variables into vars/*.yml files unless necessary

it's necessary if these variables are used/included in many places or they
contain lots of data which might be hard to inline (say, SSH keys).

don't extract, say, packages to install or directories to create which are
used in one task only:

{% raw %}
```yaml
- name: Install common packages
  apt:
    name: "{{ item }}"
    update_cache: yes
    cache_valid_time: 3600
    state: present
  loop:
    - git
    - htop
    - mc
    - ccze
```
{% endraw %}

### don't use shorthand syntax for `include_vars` module

in general always use parameter names to avoid ambiguity:

{% raw %}
```yaml
# bad
- include_vars: "{{ item }}"
  loop:
    - dirs.yml
    - "nginx_{{ env }}.yml"

# good
- include_vars:
    file: "{{ item }}"
  loop:
    - dirs.yml
    - "nginx_{{ env }}.yml"
```
{% endraw %}

### don't use Jinja2 templating delimiters in when statements

1. <https://github.com/ansible/ansible/issues/22397>

{% raw %}
```yaml
# bad
- name: Upload SSL files
  copy:
    src: "{{ ssl_dir }}/"
    dest: "{{ env_dir }}/nginx/ssl"
  when: "{{ use_ssl }}"

# good
- name: Upload SSL files
  copy:
    src: "{{ ssl_dir }}/"
    dest: "{{ env_dir }}/nginx/ssl"
  when: use_ssl
```
{% endraw %}

environments
------------

1. <https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#alternative-directory-layout>
2. <https://www.digitalocean.com/community/tutorials/how-to-manage-multistage-environments-with-ansible#using-ansible-constructs-that-allow-explicit-loading-order>

```yaml
# inventories/prod/group_vars/all

env: prod
```

```yaml
# inventories/stage/group_vars/all

env: stage
```

now `env` variable is available in all plays and roles.

troubleshooting
---------------

### recursive loop detected in template string

1. <https://stackoverflow.com/a/21738751>

passing through variables to included roles might lead to recursive loop
inside the template:

{% raw %}
```
recursive loop detected in template string: {{ app_user }}
```
{% endraw %}

**solution**

1. <https://coderleaf.wordpress.com/2017/07/06/ansible-check-for-required-variables-before-role-execution/>

there at least 2 ways to solve this problem:

- don't pass through variables to roles and templates and use all currently
  defined variables in included roles and templates without all the hassle
  of passing them explicitly

  if role A includes role B, all variables included in role A become
  available to role B.

  a major drawback of this solution is that you are not explicit about role
  parameters and you never know right away what your role parameters are.

- use unique namespace (usually a role prefix) for all variables to
  avoid name clashes and recursive loop errors as a result

  this is a recommended approach now (see `style guide` section).

in any case it might be beneficial to declare required role parameters in
_defaults/main.yml_ and check they're defined right before role execution:

> <https://coderleaf.wordpress.com/2017/07/06/ansible-check-for-required-variables-before-role-execution/>
>
> Ansible does not provide a standard way to check that required variables
> are defined before executing a tsak.
>
> Ansible, relies instead on the standard mechanism of a task failing if a
> variable being used has not been defined.
>
> Sometimes you want to make sure that all required variables are defined
> before starting the tasks for a role.

```yaml
# roles/elixir_app/defaults/main.yml

elixir_app__required_vars:
  - app_name
  - app_user
  - secrets_file
  - ssl_dir
```

{% raw %}
```yaml
# roles/elixir_app/tasks/main.yml

- name: Check required vars
  fail: msg="Variable '{{ item }}' is not defined"
  when: item not in vars
  loop: "{{ elixir_app__required_vars }}"

# other tasks...
```
{% endraw %}
